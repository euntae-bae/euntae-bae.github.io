---
layout: page
title:  "Hyeong Pesudo Assembler"
date:   2020-02-21
nav_order: 99
#permalink: test/hyeong-assembler/
categories: post
---
# 혀엉... 의사 어셈블러(Hyeong Pseudo Assembler) by catnip1917

## 기본 명령어
### 2주소 명령어의 피연산자
* op1: 글자수; 일반적으로 스택에서 꺼낼 데이터 개수를 지정할 때 사용한다.
* op2: 마침표 개수; 일반적으로 연산 결과를 저장할 스택의 번호를 지정할 때 사용한다.

### push op1, op2: 형, 혀어엉...
현재 스택에 op1 * op2를 저장한다.  
  
### popa op1, op2: 항, 하아앙...
현재 스택으로부터 op1개 만큼의 데이터를 뽑아서 그 총합을 op2번 스택에 저장한다.  
  
### popm op1, op2: 핫, 하아앗...
현재 스택으로부터 op1개 만큼의 데이터를 뽑아서 그 전체곱을 op2번 스택에 저장한다.  
  
### neg op1, op2: 흣, 흐으읏...
스택에서 op1개 원소의 부호를 반전 시키고, 그 원소들의 합을 op2번 스택에 저장한다.  
  
### rcp op1, op2: 흡, 흐으읍...
스택에서 op1개 원소에 역수(reciprocal)를 취한다음, 그 곱을 op2번 스택에 저장한다.  
  
### dup op1, op2: 흑, 흐으윽...
현재 스택의 top을 op2번 스택에 op1개 복제한다. 그리고 현재 스택을 op2로 변경한다.  
  
  
## 제어 명령어
### reg op: ♥, ❤, 💕, 💖, 💗, 💘, 💙, 💚, 💛, 💜, 💝
바로 앞에 있는 명령어를 등록한다. 본래 `혀엉...`언어에서는 하트 기호가 등록과 점프의 기능을 전부 수행하지만, 가독성을 위해 등록과 점프를 서로 다른 명령어로 분리했다. `reg`와 `jmp` 명령어는 생성되는 코드가 서로 같지만, 차이점이 있다면 어셈블 단계에서 중복 등록이 이루어지는 경우 경고(오류는 아니다)를 내보낸다. `reg`와 `jmp`의 피연산자는 1번부터 11번을 사용한다. 자세한 건 [하트 기호 매핑] 절을 참조할 것.
  
### jmp op: ♥, ❤, 💕, 💖, 💗, 💘, 💙, 💚, 💛, 💜, 💝
바로 앞에 있는 명령어로 점프한다. 등록된 명령어가 없을 경우 어셉블러 경고를 내고내고 `reg`와 동일하게 기능한다. 피연산자 op는 1번부터 11번을 사용한다.
  
### jrc: ♡
등록된 명령어로 넘어가게 하는 명령어 중 가장 최근에 실행된 명령어로 넘어간다. 없을 경우 넘어가지 않는다. 
어셈블러 수준에서는 경고로 처리하고 오류로는 처리하지 않는다. 어셈블러에서 0번으로 매핑된 `♡`기호를 코드로 생성한다. `reg`나 `jmp` 명령어와 달리 단일 기호를 사용하므로 이 명령어는 별도의 피연산자를 명시할 필요가 없다(implied).
  
### ble: a?b
현재 스택에서 값을 하나 뽑아 이전 명령어의 글자 수와 마침표 개수를 곱한 값과 비교한다. 
스택에서 뽑은 값이 더 작으면 앞 구역을 실행하고 그렇지 않으면 뒷 구역을 실행한다.  
  
### beq: a!b
현재 스택에서 값을 하나 뽑아 이전 명령어의 글자 수와 마침표 개수를 곱한 값과 비교한다. 
서로 같으면 앞 구역을 실행하고 그렇지 않으면 뒷 구역을 실행한다.
  
  
## 하트 기호 매핑
어셈블리어 코드에서는 하트 이모지 사용의 편의를 위해 `혀엉...`언어에서 사용하는 하트 이모지들을 각각 0번부터 11번까지 대응시켰다.  
  
|기호|유니코드|대응 번호|
|:--:|:------:|:-------:|
|♡ |U+2661 |0 |
|♥ |U+2665 |1 |
|❤ |U+2764 |2 |
|💕|U+1F495|3 |
|💖|U+1F496|4 |
|💗|U+1F497|5 |
|💘|U+1F498|6 |
|💙|U+1F499|7 |
|💚|U+1F49A|8 |
|💛|U+1F49B|9 |
|💜|U+1F49C|10|
|💝|U+1F49D|11|

[하트 기호 매핑]: #하트-기호-매핑