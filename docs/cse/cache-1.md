---
layout: post
title: "캐시의 기본"
parent: "Computer Science"
nav_order: 4
---

# 캐시의 기본

**캐시의 구성 요소**: 블록 주소, 태그, 유효 비트  
  
이 절에서는 프로세서가 한 순간에 필요로 하는 데이터는 한 워드이고, 블록 또한 한 워드로만 이루어진 아주 단순한 캐시를 먼저 살펴본다. 프로세서가 캐시에 없는 Xn이라는 워드를 요청한다면 이 요구는 실패를 발생시키고 워드 Xn을 메모리로부터 캐시로 가져오게 된다. 그렇다면 두 가지 의문이 제기된다.
1. 데이터가 캐시 내에 있는지 어떻게 알 수 있는가?
2. 알 수 있다면 어떻게 찾을 수 있는가?

각 워드가 캐시 내의 딱 한 장소에만 있을 수 있다면 워드가 캐시 내에 있는지 없는지를 바로 알 수 있다. 메모리의 각 워드에 캐시 내의 위치를 할당하는 가장 간단한 방법은 **메모리 주소**에 기반을 두고 할당하는 것이다. 이 캐시 구조를 **직접 사상(direct mapped)**이라 한다. 왜냐하면 각 메모리 위치는 캐시 내의 딱 한 장소에 직접 사상되기 때문이다.  
  
* **직접 사상:** 각 메모리의 위치가 캐시 내의 정확히 한 곳에만 사상되는 캐시 구조  
  
거의 모든 직접 사상 캐시는 블록을 찾기 위하여 다음의 사상 방식을 사용한다.
```
    (블록 주소) modulo (캐시 내에 존재하는 전체 캐시 블록 수)
```
  
예를 들어 8-블록 캐시는 **블록 주소**로 (메모리 주소의)하위 3비트를 사용한다. 각 캐시 엔트리는 여러 주소의 메모리 내용을 적재할 수 있다. 메모리 주소 00001, 01001, 10001 등에 있는 워드는 캐시의 001로, 메모리 주소 00100, 01100, 11100 등에 있는 워드는 캐시의 100으로 사상된다.  
  
그러나 이렇게 된다면 캐시 내의 워드가 프로세서가 요구하는 것과 일치하는지를 알 수 없다. 이 문제는 **태그(tag)**를 추가함으로써 해결할 수 있다. 
태그는 캐시 내의 워드가 요청한 것인지 아닌지를 식별하는 데 필요한 주소 정보를 포함한다. 태그는 캐시의 인덱스로 사용되지 않은 주소의 윗부분 비트로 구성된다. 
예를 들어 주소 비트의 하위 3비트 인덱스 필드가 블록을 선택하는 데 사용되었으므로, 태그는 5비트의 주소 필드 중 상위 2비트가 된다. **태그 구조는 중복되는 인덱스 비트를 생략한다. 왜냐하면 캐시 블록 주소의 인덱스 필드는 그 블록의 번호이기 때문**이다.  
  
* **태그:** 특정 계층에서 해당 블록이 요청한 워드와 일치하는지를 알려 주는 주소 정보를 담고 있는 필드  
  
또한 캐시 블록이 유효한 정보를 가지고 있는지를 알아내는 방법이 필요하다. 예를 들어 프로세서가 맨 처음 작업을 시작하면 캐시는 비어 있을 것이며, 태그 필드는 의미가 없을 것이다. 이런 엔트리들은 무시되어야 한다. 가장 많이 쓰이는 방법은 엔트리가 타당한 주소를 포함하는지를 표시하기 위해 **유효 비트(valid bit)**를 캐시에 첨가하는 것이다.  
  
* **유효 비트:** 특정 계층에서 해당 블록이 유효한 데이터를 포함하는지를 알려 주는 필드  
  
> 캐시는 지역성(locality)의 원칙을 이용해서 메모리 상위 계층에서 필요한 데이터를 찾는다. 상위 계층에서 예측이 틀렸을 경우에는 하위 계층에서 적합한 데이터를 찾을 수 있는 기법을 제공한다. 현대 컴퓨터의 캐시 예측 적중률은 95% 이상이다.  
  
<br>

## 캐시 접근
캐시 구현에 필요한 총 비트 수는 캐시의 크기와 주소의 크기에 따라 결정된다. 왜냐하면 캐시는 데이터뿐만 아니라 태그를 위한 장소를 필요로 하기 때문이다. 위에서 블록의 크기는 한 워드였지만 일반적으로는 여러 개의 워드가 된다. 아래와 같은 가정에서
- 32비트의 주소
- 직접 사상 캐시
- 캐시는 2^n개 블록을 가지고 있고 n개 비트는 인덱스를 위하여 사용된다.
- 캐시 블록의 크기는 2^m개 워드(2^m+2개 바이트)이다. m개 비트는 블록 내부에서 워드 구별에 쓰이며, 두 비트는 주소 중 바이트 구별용으로 쓰인다.
  
태그 필드의 크기는
```
    32 - (n + m + 2)
```
이다. 그리고 직접 사상 캐시의 전체 비트 수는
```

```

## 쓰기의 처리
* 즉시 쓰기(write-through)
* 쓰기 버퍼(write buffer)
* **나중 쓰기(write-back)**: 단지 캐시에 있는 블록의 값만을 갱신하여 쓰기를 수행하고 그 블록이 교체될 때 메모리 계층구조의 하위 계층에 갱신된 블록이 쓰이는 방식

저장(쓰기) 명령어를 가정해 보자. 데이터를 데이터 캐시에만 쓰고 메인 메모리에는 쓰지 않을 경우, 메인 메모리는 캐시와는 다른 값을 갖게 된다. 이 경우에 캐시와 메모리는 불일치(inconsistent)한다고 말한다. 메인 메모리와 캐시를 일치시키는 가장 쉬운 방법은 항상 데이터를 메모리와 캐시에 같이 쓰는 것이다. 이 방법을 **즉시 쓰기(write-through)**라고 한다. 이 방식은 설계를 잘한다고 하더라도 좋은 성능을 제공하기 어렵다. 즉시 쓰기 방식에서는 모든 쓰기가 메인 메모리에 

나중 쓰기(write-back) 방식에서는 쓰기가 발생했을 때 새로운 값은 캐시 내의 블록에만 쓴다. 그러다가 나중에 캐시에서 쫓겨날 때 쓰기에 의해 내용이 바뀐 블록이면 메모리 계층구조에서 더 낮은 계층에 써진다. 나중 쓰기 방식은 특히 메인 메모리가 처리할 수 있는 속도보다 프로세서가 쓰기를 더 빠르게 발생시키는 경우에 성능을 향상시킬 수 있다. 그러나 나중 쓰기 방식은 즉시 쓰기 방식보다 구현하기가 더 힘들다.
> write-back: 캐시에만 쓰다가 캐시 엔트리에서 쫓겨날 때 메모리에 쓰는 방식
> 장점: write-throuch보다 훨씬 빠르다.
> 단점: 한동안 캐시에서만 갱신이 일어나기 때문에, 캐시와 메인 메모리의 값이 불일치하는 문제가 발생한다.
