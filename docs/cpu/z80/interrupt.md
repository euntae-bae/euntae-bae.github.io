---
layout: post
title: "Z80의 인터럽트"
parent: Z80
grand_parent: CPU
nav_order: 7
---

# Z80의 인터럽트

## 1. NMI(Non-Maskable Interrupt)
NMI는 대부분의 마이크로프로세서의 외부 핀으로 독립적으로 설계되어 있으며 인터럽트 플립플롭에 관계 없이 인터럽트를 요청할 수 있는 방법이다.

### (1). NMI의 특징
- NMI는 인터럽트 중 우선순위가 가장 높은 인터럽트이다.  
- 인터럽트 플립플롭과 관계 없이 인터럽트를 요구할 수 있다.  
- NMI는 Low 활성이다.  
- Z80에서 NMI가 발생하면 무조건 제로 페이지의 $66 번지로 점프한다.  
- $66 번지에 NMI 서비스 루틴의 시작 주소가 저장되어 있다.  
<br>

### (2). NMI 동작 순서
**초기값:** NMI의 ISR이 $5000 번지에 위치한다고 가정하고 $0066에 $5000으로 점프하는 명령어를 기억시켜둔다.  
  
1. 주변장치에서 CPU로 /NMI 신호를 보내 인터럽트를 요청한다.  
2. CPU는 현재 실행하던 명령어를 완료하고 현재 PC 내용을 스택으로 피신시킨 다음 PC에 $0066을 로드하여 제로 페이지 $66번지로 점프한다.  
3. $0066번지에 저장되어 있는 Jump $5000에 의해 $5000으로 점프한다.  
4. $5000에 정의된 ISR을 실행한다.  
5. Return 명령어(RETN)에 의해 스택에 저장되어 있던 기존의 PC 주소를 PC로 복구하여(WIP)   
  
<br>

## 2. INT(Maskable Interrupt)
INT는 마스커블 인터럽트로서 CPU 내부에 있는 인터럽트 플립플롭이 1로 세트되어 있어야만 인터럽트 요청을 받아들일 수 있는 인터럽트이다.

### (1). 인터럽트 제어 명령어
**EI(Enable Interrupt)**  
**DI(Disable Interrupt)**  
**RETI(Return from an Interrupt routine):** ISR 종료 및 복귀  
**RETN(Return from the NMI):** NMI 종료 및 복귀  
**IM 0, IM 1, IM2 (Interrupt Mode):** 인터럽트 모드 설정  
<br>

### (2). 인터럽트 모드
INT는 동장 방법에 따라 모드0, 모드1, 모드2로 분류된다.  
  
**모드0:**  
- 제로 페이지를 이용하여 하드웨어 및 소프트웨어적으로 ISR을 구성하여 실행하는 방법으로 RST 명령어에 의해 실행되는 방법이다.  
**RST(Restart)**  
- call 명령어와 유사하게 특정한 주소로 점프하여 리턴 명령어를 만나기 이전까지 코드를 수행한다.  
- 그러나 일반적인 call 명령어와 다르게 rst 명령어는 1바이트만을 차지한다.  
- 또한 rst 명령어는 점프가 가능하도록 미리 설정된 주소가 제한적이다: $0000, $0008, $0010, $0018, $0020, $0028, $0030  
  

|명령어   |설명                                                  |
|:-----:|-----------------------------------------------------|
|RST 00H|컴퓨터 시스템을 초기화하는 기능                             |
|RST 08H|사용자 프로그램을 종료하고 시스템에게 제어를 반환한다.           |
|RST 10H|HL 레지스터 값을 ASCII code로 변환하여 모니터로 출력하는 기능 |
|RST 18H|Acc 값을 ASCII 코드로 변환하여 모니터로 출력하는 기능        |
|RST 20H|PC(Personal Computer)로 한 개 문자를 출력하는 기능          |
|RST 28G|PC에서 한 개 문자를 입력받는 기능                           |
|RST 30H||
|RST 38H||
  

- 모드0 인터럽트를 실행하기 위해서는 위에 있는 각 제로 페이지 주소들에 인터럽트 루틴의 시작주소를 호출하는 명령어들을 저장해둬야 한다.  
* 인터럽트 벡터에는 ISR로의 점프 명령어 저장  
* 위에 있는 인터럽트들은 주변 장치 등에서 하드웨어적으로 요청될 수도 있지만, 프로그램에서 RST 명령어를 이용하여 소프트웨어적인 인터럽트 요청이 가능하다.  
> 예를 들어 인터럽트 모드0로 세트된 상태에서 주변장치로부터 RST 00H의 opcode인 $C7을 CPU로 전송하면 $0000번지로 점프하여 시스템을 초기화시킨다.

* 즉, **RST 명령어는 소프트웨어 인터럽트**다.  
<br>

**모드1:**  
- 모드1은 모드0 인터럽트 중에서 우선순위가 가장 높은 RST 38H를 말한다. 동작과정은 모드0과 동일하다.  
  
**모드2:**  
- 모드2는 벡터 인터럽트라고 하며 인터럽트 중에서 가장 강력한 기능을 가지고 있다.  
- 이 방법은 한 개의 컴퓨터시스템에서 최대 128개의 ISR을 구성할 수 있다.  
- 모드2는 인터럽트 벡터 레지스터(I)를 사용하여 주변장치에서 전송된 하위 8비트 주소 정보와 인터럽트 벡터 레지스터의 내용을 합하여 ISR을 호출한다.  
<br>

**왜 128개인가?**
- Z80의 주소 길이는 2바이트이다. 즉, 각각의 벡터 주소는 2바이트를 차지한다.  
- 인터럽트 벡터 레지스터에는 인터럽트 벡터 주소의 상위 바이트를 저장해두고, 하위 바이트를 주변장치로부터 받아 인터럽트 벡터로 점프하므로 지정 가능한 ISR의 개수는 이 하위 바이트만큼으로 한정되는데, 각 벡터 주소는 2바이트를 차지하므로 `256($00~$FF) / 2 = 128`  
<br>

### (3). 모드2 인터럽트의 실행 과정
**1). 인터럽트 벡터 구성**  
- 예를 들어 $9000번지부터 $90FF까지 인터럽트 벡터를 구성한다고 가정하면, $9000-$90FF의 영역에는 각각 2바이트 ISR의 주소가 저장될 것이다(최대 128개).  
<br>

**2). 모드2의 초기화**  
- 벡터 인터럽트를 사용하기 위해 일련의 초기화 과정을 거친다.  
1. IM 2를 실행하여 인터럽트 모드를 2로 설정  
2. IE를 실행하여 인터럽트 플립플롭을 1로 설정  
3. 인터럽트 벡터 레지스터에 인터럽트 벡터의 상위 바이트 주소 $90을 저장한다.  
<br>

**3). 실행 예시: I=$90, ($9002): $00, ($9003): $A1 이라고 가정**  
1. 주변장치에서 IRQ 신호 전송  
2. CPU는 현재 실행하던 명령어를 완료하고 INT 확인(ACK) 신호를 전송한다.  
3. PC 내용을 스택에 저장한다.  
4. 주변장치로부터 받은 인터럽트 벡터 하위 바이트 주소 $02를 CPU로 전송한다.  
5. 인터럽트 벡터 레지스터의 값과 주변장치로부터 전송된 주소 값을 결합하여 인터럽트 벡터 주소를 구성한다. `($9002)`  
6. $9002에 내장된 주소인 $A100 를 호출한다.  
7. ISR이 실행된다.  
    
<br>

### 참고 문헌
* 남시병 2015, 《마이크로프로세서》, 두양사.  
* <http://z80-heaven.wikidot.com/instructions-set>