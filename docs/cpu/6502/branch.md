---
layout: post
title: "분기 명령어"
parent: 6502
grand_parent: CPU
nav_order: 7
---

# 분기 명령어
**피연산자 기호**  
**addr:** direct address, 16비트 직접 주소 ($0000~$FFFF)  
**(addr):** indirect address, 16비트 간접 주소  
**rel:** relative addresss, 8비트 상대 주소(-128~+127)  
  
*분기 명령어는 상태 플래그에 **아무 영향을 미치지 않는다.** 따라서 본문에서는 상태 플래그 표기를 생략하도록 한다.*  
  
<br>

## 서론
분기 명령어의 기본 원리는 프로그램 카운터(PC)의 값을 변경하여 바로 다음에 실행할 명령어의 위치를 바꾸는 것이다.  
  
분기 명령어는 크게 무조건 분기 명령어와 조건 분기 명령어로 분류되는데, 무조건 분기는 흔히 점프 명령어라고 부르는 명령어 집합을 가리킨다. 6502에서 무조건 분기 명령어는 JMP 명령어 하나만 제공한다. 
나머지 하나인 조건 분기 명령어는 상태 레지스터에 있는 플래그 값을 검사해서 조건부로 점프하는 명령어 집합이다. 고급 언어의 if-else 문이나 switch 문같은 제어 구조들을 구현할 때 이러한 조건 분기 명령어를 사용한다. 반면 무조건 분기 명령어는 고급 언어의 goto문을 구현할 때 사용된다.  

조건 분기 명령어는 현재의 상태 플래그를 검사하기 때문에 분기 명령어를 사용하려면 이전에 산술 연산이나 비교 연산을 수행해야 한다.  
  
무조건 분기 명령어와 조건 분기 명령어의 피연산자는 모두 점프할 명령어의 주소값이지만 구체적인 피연산자의 형식은 서로 다르다. 
무조건 분기 명령어는 16비트 직접 주소와 간접 주소를 사용하는데, 간접 주소 지정 방식을 사용하면 지정한 주소로 직접 점프하는 것이 아니라, 해당 번지에 있는 또 다른 주소값을 읽어서 그 주소로 점프하게 된다. 
간접 주소를 사용하면 점프할 주소의 위치를 프로그램 실행중에 동적으로 바꿀 수 있다는 장점이 있지만, 분기 주소를 읽어들이기 위한 추가적인 클럭 사이클을 필요로 한다.  
  
조건 분기 명령어는 ==상대 주소지정방식(relative addressing)==을 사용한다. 
상대 주소는 프로그램 카운터(PC)와 점프할 명령어 사이의 상대적인 위치, 즉 변위(displacement)다. 이때 조건 분기 명령어가 2바이트 명령어라는 점에 주의해야 한다. 
조건 분기 명령어의 피연산자로 주어지는 변위값은 부호 있는 1바이트 정수값(-128~+127)으로 제한되기 때문에 1바이트 범위 이내의 근접 점프만 가능하다.  
  
상대 주소는 어셈블러가 계산하기 때문에 상대 주소 계산에 신경 쓸 필요 없이 점프할 명령어의 레이블을 피연산자로 명시하면 된다.  
  
<br>

## 1. 무조건 분기 명령어 (점프 명령어)
**JMP**  
Jump to New Location; 지정된 주소로 점프  
```
JMP addr
JMP (addr)
```
<br>

## 2. (조건) 분기 명령어
**BEQ**  
Branch on Result Zero / Branch on Equal; 비교 결과가 같을(Z = 1) 때 점프
```
BEQ rel
```
<br>

**BNE**  
Branch on Result not Zero / Branch on Not Equal; 비교 결과가 같지 않을(Z != 0) 때 점프  
```
BNE rel
```
<br>

**BMI**  
Branch on Result Minus; 비교 결과가 음수(N=1)일 때 점프  
```
BMI rel
```
<br>

**BPL**  
Branch on Result Plus; 비교 결과가 양수(N=0)일 때 점프  
```
BPL rel
```
<br>

**BCS**  
Branch on Carry Set; 캐리 비트가 1(C=1)일 때 점프  
```
BCS rel
```
<br>

**BCC**  
Branch on Carry Clear; 캐리 비트가 0(C=0)일 때 점프  
```
BCC rel
```
<br>

**BVS**  
Branch on oVerflow Set; 오버플로우 비트가 1(V=1)일 때 점프  
```
BVS rel
```
<br>

**BVC**  
Branch on oVerflow Clear; 오버플로우 비트가 0(V=0)일 때 점프  
```
BVC rel
```
<br>

## 요약
### 무조건 분기 명령어 (점프 명령어)
* JMP  
  

### (조건) 분기 명령어
* BEQ, BNE, BMI, BPL, BCS, BCC, BVS, BVC  
  
- 분기 명령어는 상태 플래그에 영향을 미치지 않는다.  
- 조건 분기 명령어의 상태 플래그를 이용하여 조건을 검사한다.  
- 점프 명령어는 직접 주소와 간접 주소를 피연산자로 사용한다.  
- 분기 명령어는 상대 주소를 피연산자로 사용한다.  
- 상대 주소는 PC(Program Counter)와 점프할 명령어 주소의 상대적 위치를 나타내며, 이 변위(displacement 또는 offset)값은 부호 있는 1바이트 정수이다.  
  
<br>

### 참고자료
<https://www.masswerk.at/6502/6502_instruction_set.html>